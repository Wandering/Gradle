# Gradle用户指南

版权所有©2007-2017 Hans Dockter，Adam Murdoch

本文档的副本可以为您自己使用并分发给其他人，前提是您不收取这些副本的任何费用，并进一步规定每份副本均包含此版权声明，无论是以印刷版还是电子版分发.

**目录**
------
## [I. 关于Gradle](第一部分%20关于%20Gradle.md)
[1\. 介绍](第一章%20介绍.md)\
[2\. 概述](第二章%20概述.md)
## [II. 使用现行版本](第二部分%20使用现有的版本.md)
[3. 安装Gradle](第三章%20安装Gradle.md)\
[4. 使用Gradle命令行](第四章%20使用Gradle命令行.md)\
[5. Gradle控制台](第五章%20Gradle控制台.md)\
6\. Gradle包装器\
7\. Gradle守护进程\
8\. 依赖管理基础\
9\. 介绍多项目构建\
10\. 连续构建\
11\. 复合构建\
12\. 构建环境\
13\. 故障排除\
14\. 使用Tooling API嵌入Gradle\
15\. 构建缓存
## [III.编写Gradle构建脚本]()
16\. 构建脚本基础\
17\. 构建Init插件\
18\. 编写生成脚本\
19\. 关于任务的更多信息\
20\. 使用文件\
21\. 使用Gradle中的Ant\
22\. 构建生命周期\
23\. 包装插件\
24\. 记录\
25\. 依赖管理\
26\. 多项目构建\
27\.  Gradle插件\
28\. 标准的Gradle插件\
29\. 项目报告插件\
30\. 生成仪表板插件\
31\. 比较构建\
32\. 发布工件\
33\.  Maven插件\
34\. 签名插件\
35\. 常春藤出版（新）\
36\.  Maven Publishing（新）\
37\. 分配插件\
38\. 宣传插件\
39\. 生成公告插件
## [IV.扩展构建]()
40\. 编写自定义任务类\
41\. 编写自定义插件\
42\. Java Gradle插件开发插件\
43\. 组织构建逻辑\
44\. Lazy 的配置\
45\. 初始化脚本\
46\. Gradle TestKit
## [V.构建JVM项目]()
**Java快速入门**
48\. Java插件\
49\. Java库插件\
50\. Web应用程序快速入门\
51\. War 插件\
52\. Ear 插件\
53\. Jetty 插件\
54\. 应用程序插件\
55\. Java 库分发插件\
56\. Groovy 快速入门\
57\. Groovy 插件\
58\. Scala 插件\
59\. ANTLR 插件\
60\. Checkstyle 插件\
61\. CodeNarc 插件\
62\. FindBugs 插件\
63\. JDepend插件\
64\. PMD插件\
65\. JaCoCo插件\
66\. OSGi插件\
67\. Eclipse插件\
68\. IDEA插件
## VI.软件模型
69\.基于规则的模型配置\
70\.软件模型概念\
71\.在插件中实现模型规则\
72\.构建Java库\
73\.构建Play应用程序\
74\.构建本地软件\
75\.扩展软件模型
## 七.附录
A\. Gradle样本\
B\.潜在的陷阱\
C\.功能生命周期\
D\. Gradle命令行\
E\.文件许可证


**例子列表**

4.1 执行多个任务\
4.2 排除任务\
4.3 缩写的任务名称\
4.4 缩写骆驼案例任务名称\
4.5 使用构建文件选择项目\
4.6 使用项目目录选择项目\
4.7 强制任务运行\
4.8 获取有关项目的信息\
4.9 提供一个项目的描述\
4.10 获取有关任务的信息\
4.11 更改任务报告的内容\
4.12 获取更多关于任务的信息\
4.13 获得详细的帮助任务\
4.14 获取有关依赖关系的信息\
4.15 通过配置过滤依赖关系报告\
4.16 深入了解特定的依赖关系\
4.17 有关属性的信息\
6.1 运行包装任务\
6.2 包装任务\
6.3 包装器生成的文件\
6.4 使用系统属性指定HTTP基本身份验证凭据\
6.5 在中指定HTTP基本身份验证凭证distributionUrl\
6.6 配置SHA-256校验和验证\
8.1 声明依赖关系\
8.2 定义一个外部依赖\
8.3 外部依赖的快捷方式定义\
8.4 使用Maven中央资料库\
8.5 使用JCenter存储库\
8.6 远程Maven仓库的使用\
8.7 远程Ivy目录的用法\
8.8 本地Ivy目录的用法\
8.9 发布到常春藤资源库\
8.10 发布到Maven仓库\
9.1 列出构建中的项目\
11.1 我的应用程序的依赖关系\
11.2 声明一个命令行组合\
11.3 声明一个单独的组合\
11.4 根据包含的构建任务\
11.5 建立不声明组属性\
11.6 为包含的构建声明替换\
11.7 取决于包含的构建中的单个任务\
11.8 取决于所有包含的构建中的路径任务\
12.1 使用gradle.properties文件设置属性\
12.2 配置HTTP代理\
12.3 配置HTTPS代理\
14.1 使用工具API\
15.1 配置本地缓存\
15.2 从HttpBuildCache拉\
15.3 配置远程HTTP缓存\
15.4 为HttpBuildCache允许不受信任的SSL证书\
15.5 CI推荐用例的建议设置\
15.6 一致的buildSrc和主版本的设置\
15.7 初始化脚本来配置构建缓存\
16.1 你的第一个构建脚本\
16.2 执行构建脚本\
16.3 任务定义快捷方式\
16.4 在Gradle的任务中使用Groovy\
16.5 在Gradle的任务中使用Groovy\
16.6 取决于其他任务的任务宣言\
16.7 懒惰取决于 - 其他任务不存在（还）\
16.8 动态创建任务\
16.9 通过API访问任务 - 添加依赖项\
16.10 通过API访问任务 - 添加行为\
16.11 作为构建脚本的属性访问任务\
16.12 为任务添加额外的属性\
16.13 使用AntBuilder执行ant.loadfile目标\
16.14 使用方法来组织你的构建逻辑\
16.15 定义一个默认的任务\
16.16 不同的结果取决于选择的任务\
18.1 访问Project对象的属性\
18.2 使用局部变量\
18.3 使用额外的属性\
18.4 配置任意对象\
18.5 使用脚本配置任意对象\
18.6 Groovy JDK方法\
18.7 物业访问者\
18.8 没有括号的方法调用\
18.9 列表和地图文字\
18.10 作为方法参数关闭\
18.11 关闭代表\
19.1 定义任务\
19.2 定义任务 - 使用字符串作为任务名称\
19.3 使用替代语法定义任务\
19.4 作为属性访问任务\
19.5 通过任务收集访问任务\
19.6 通过路径访问任务\
19.7 创建一个复制任务\
19.8 配置一个任务 - 不同的方式\
19.9 配置一个任务 - 关闭\
19.10 用闭包定义一个任务\
19.11 从另一个项目添加依赖任务\
19.12 使用任务对象添加依赖项\
19.13 使用闭包添加依赖关系\
19.14 添加'必须在任务排序后运行'\
19.15 添加'应该运行'任务排序\
19.16 任务排序并不意味着任务执行\
19.17 如果引入了一个订购周期，则应该在任务排序之后运行'A'\
19.18 将描述添加到任务\
19.19 覆盖任务\
19.20 使用谓词跳过任务\
19.21 用StopExecutionException跳过任务\
19.22 启用和禁用任务\
19.23 自定义任务类\
19.24 临时任务\
19.25 宣布可销毁的临时任务\
19.26 使用自定义任务类型的运行时API\
19.27 通过运行时API使用skipWhenEmpty（）\
19.28 通过任务输出推断任务依赖关系\
19.29 通过任务参数推断任务依赖关系\
19.30 声明一个方法来添加任务输入\
19.31 声明一个方法来添加一个任务作为输入\
19.32 尝试设置推断的任务依赖关系失败\
19.33 在输出目录和输入文件之间建立推断的任务依赖关系\
19.34 使用文件（）设置推断的任务依赖关系\
19.35 使用builtBy（）设置推断的任务依赖关系\
19.36 忽略最新的检查\
19.37 运行时类路径规范化\
19.38 任务规则\
19.39 依赖基于规则的任务\
19.40 添加任务终结器\
19.41 任务终结器失败的任务\
20.1 查找文件\
20.2 创建一个文件集合\
20.3 使用文件集合\
20.4 实现一个文件集合\
20.5 创建一个文件树\
20.6 使用文件树\
20.7 使用档案作为文件树\
20.8 指定一组文件\
20.9 使用复制任务复制文件\
20.10 指定复制任务源文件和目标目录\
20.11 选择要复制的文件\
20.12 使用copy（）方法复制文件而不进行最新检查\
20.13 使用最新检查的copy（）方法复制文件\
20.14 重命名文件，因为它们被复制\
20.15 在复制文件时过滤文件\
20.16 嵌套的复制规格\
20.17 使用Sync任务来复制依赖关系\
20.18 创建一个ZIP存档\
20.19 创建ZIP压缩文件\
20.20 归档任务的配置 - 自定义归档名称\
20.21 归档任务的配置 - 附录和分类器\
20.22 激活可复制的档案\
21.1 使用Ant任务\
21.2 将嵌套文本传递给Ant任务\
21.3 将嵌套元素传递给Ant任务\
21.4 使用Ant类型\
21.5 使用自定义Ant任务\
21.6 声明自定义Ant任务的类路径\
21.7 一起使用自定义Ant任务和依赖项管理\
21.8 导入Ant构建\
21.9 依赖Ant目标的任务\
21.10 将行为添加到Ant目标\
21.11 依赖于Gradle任务的Ant目标\
21.12 重命名导入的Ant目标\
21.13 设置一个Ant属性\
21.14 获取Ant属性\
21.15 设置一个Ant引用\
21.16 获取Ant参考\
21.17 微调Ant记录\
22.1 单个项目构建\
22.2 分层布局\
22.3 平面布局\
22.4 项目树元素的修改\
22.5 将测试任务添加到具有特定属性集的每个项目\
22.6 通知\
22.7 将某些属性设置为所有任务\
22.8 记录每个任务执行的开始和结束\
24.1 使用stdout写入日志消息\
24.2 编写自己的日志消息\
24.3 使用SLF4J写入日志消息\
24.4 配置标准输出捕获\
24.5 为任务配置标准输出捕获\
24.6 自定义什么Gradle日志\
25.1 定义一个配置\
25.2 访问配置\
25.3 配置配置\
25.4 模块依赖关系\
25.5 神器只有符号\
25.6 依靠分类器\
25.7 迭代配置\
25.8 客户端模块依赖关系 - 传递依赖关系\
25.9 项目依赖关系\
25.10 文件依赖关系\
25.11 生成的文件依赖关系\
25.12 Gradle API依赖关系\
25.13 Gradle的Groovy依赖\
25.14 排除传递依赖\
25.15 依赖关系的可选属性\
25.16 集合和依赖的数组\
25.17 依赖配置\
25.18 项目的依赖配置\
25.19 Configuration.copy\
25.20 访问声明的依赖关系\
25.21 Configuration.files\
25.22 配置文件\
25.23 Configuration.copy\
25.24 Configuration.copy与Configuration.files\
25.25 添加中央Maven仓库\
25.26 添加Bintray的JCenter Maven仓库\
25.27 通过HTTP使用Bintrays的JCenter\
25.28 添加Google Maven仓库\
25.29 添加本地Maven缓存作为存储库\
25.30 添加自定义的Maven仓库\
25.31 为JAR文件添加额外的Maven存储库\
25.32 访问密码保护的Maven仓库\
25.33 平面库解析器\
25.34 常春藤资料库\
25.35 具有命名布局的常青藤资源库\
25.36 常春藤库与模式布局\
25.37 常春藤资源库与多个自定义模式\
25.38 与Maven兼容布局的常春藤资源库\
25.39 常春藤资料库\
25.40 声明一个Maven和Ivy仓库\
25.41 向Maven和Ivy存储库提供凭据\
25.42 声明一个S3支持的Maven和Ivy仓库\
25.43 使用IAM声明S3支持的Maven和Ivy仓库\
25.44 使用默认应用程序凭据声明Google云端存储支持Maven和Ivy存储库\
25.45 将存储库配置为仅使用摘要式身份验证\
25.46 配置存储库以使用抢先式身份验证\
25.47 访问存储库\
25.48 存储库的配置\
25.49 定义存储库的定义\
25.50 强制一组库的一致版本\
25.51 使用自定义的版本控制方案\
25.52 用替换品列入黑名单\
25.53 在分辨率更改依赖组和/或名称\
25.54 用一个项目替代一个模块\
25.55 用一个模块替代一个项目\
25.56 有条件地取代依赖关系\
25.57 指定配置的默认依赖关系\
25.58 启用动态解析模式\
25.59 “最新”版本选择器\
25.60 自定义状态方案\
25.61 按模块自定义状态方案\
25.62 常春藤组件元数据规则\
25.63 规则源组件元数据规则\
25.64 组件选择规则\
25.65 具有模块目标的组件选择规则\
25.66 元数据的组件选择规则\
25.67 使用规则源对象的组件选择规则\
25.68 声明模块更换\
25.69 动态版本缓存控制\
25.70 更改模块缓存控制\
26.1 多项目树 - 水和蓝鲸项目\
26.2 建立水（母）项目的脚本\
26.3 多项目树 - 水，蓝鲸和磷虾项目\
26.4 水项目建设脚本\
26.5 定义所有项目和子项目的共同行为\
26.6 定义特定项目的特定行为\
26.7 定义项目磷虾的具体行为\
26.8 向一些项目添加自定义行为（按项目名称过滤）\
26.9 将自定义行为添加到某些项目（由项目属性过滤）\
26.10 从子项目运行生成\
26.11 评估和执行项目\
26.12 评估和执行项目\
26.13 通过绝对路径运行任务\
26.14 依赖和执行顺序\
26.15 依赖和执行顺序\
26.16 依赖和执行顺序\
26.17 声明依赖关系\
26.18 声明依赖关系\
26.19 跨项目任务依赖关系\
26.20 配置时间依赖关系\
26.21 配置时间依赖关系 - evaluationDependsOn\
26.22 配置时间依赖关系\
26.23 相关性 - 真实生活的例子 - 交叉项目配置\
26.24 项目库依赖关系\
26.25 项目库依赖关系\
26.26 细粒度地控制依赖关系\
26.27 建立和测试单个项目\
26.28 部分构建和测试单个项目\
26.29 建立和测试取决于项目\
26.30 建立和测试相关项目\
27.1 应用脚本插件\
27.2 应用核心插件\
27.3 应用社区插件\
27.4 仅对某些子项目应用插件.\
27.5 使用自定义插件存储库中的插件.\
27.6 插件分辨率策略.\
27.7 完成插件发布示例\
27.8 应用二进制插件\
27.9 按类型应用二进制插件\
27.10 应用一个插件与buildscript块\
30.1 使用生成仪表板插件\
32.1 使用归档任务定义工件\
32.2 使用文件定义工件\
32.3 自定义工件\
32.4 用于使用文件定义工件的映射语法\
32.5 上传任务的配置\
33.1 使用Maven插件\
33.2 创建一个独立的pom.\
33.3 将文件上传到远程Maven存储库\
33.4 通过SSH上传文件\
33.5 pom的定制\
33.6 pom的生成器风格定制\
33.7 修改自动生成的内容\
33.8 Maven安装程序的自定义\
33.9 生成多个poms\
33.10 访问映射配置\
34.1 使用签名插件\
34.2 签署配置\
34.3 签署配置输出\
34.4 签署一项任务\
34.5 签署任务输出\
34.6 有条件签名\
34.7 签署POM进行部署\
35.1 应用“ivy-publish”插件\
35.2 发布一个Java模块给Ivy\
35.3 向艾薇发布更多的神器\
35.4 定制发布标识\
35.5 定制模块描述符文件\
35.6 从单个项目发布多个模块\
35.7 声明存储库发布到\
35.8 选择要发布的特定出版物\
35.9 通过“发布”生命周期任务发布所有发布\
35.10 生成常青藤模块描述符文件\
35.11 发布一个Java模块\
35.12 生成ivy.xml的例子\
36.1 应用“maven-publish”插件\
36.2 为Java组件添加一个MavenPublication\
36.3 将其他工件添加到MavenPublication中\
36.4 定制发布标识\
36.5 修改POM文件\
36.6 从单个项目发布多个模块\
36.7 声明存储库发布到\
36.8 将项目发布到Maven存储库\
36.9 将项目发布到Maven本地存储库\
36.10 生成POM文件而不发布\
37.1 使用分配插件\
37.2 添加额外的分配\
37.3 配置主分配\
37.4 发布主要分布\
38.1 使用通告插件\
38.2 配置通告插件\
38.3 使用通告插件\
39.1 使用构建公告插件\
39.2 从初始化脚本使用构建公告插件\
40.1 定义一个自定义的任务\
40.2 你好世界任务\
40.3 一个可定制的hello世界任务\
40.4 构建自定义任务\
40.5 自定义任务\
40.6 在另一个项目中使用自定义任务\
40.7 测试一个自定义任务\
40.8 定义增量任务操作\
40.9 第一次运行增量任务\
40.10 以不变的输入运行增量任务\
40.11 用更新的输入文件运行增量任务\
40.12 运行删除输入文件的增量任务\
40.13 运行删除了输出文件的增量任务\
40.14 运行更改的输入属性的增量任务\
40.15 创建一个工作单位的实施\
40.16 提交一个工作单元执行\
40.17 等待异步工作完成\
40.18 提交工作项目以在工作守护程序中运行\
41.1 自定义插件\
41.2 自定义插件扩展\
41.3 具有配置关闭的自定义插件\
41.4 懒惰地评估文件属性\
41.5 扩展属性映射到任务属性\
41.6 构建自定义插件\
41.7 为自定义插件配线\
41.8 在另一个项目中使用自定义插件\
41.9 应用社区插件与插件DSL\
41.10 测试一个自定义的插件\
41.11 使用Java Gradle插件开发插件\
41.12 嵌套的DSL元素\
41.13 管理对象的集合\
42.1 使用Java Gradle插件开发插件\
42.2 使用gradlePlugin {}块.\
43.1 使用继承的属性和方法\
43.2 使用注入的属性和方法\
43.3 使用外部构建脚本配置项目\
43.4 自定义buildSrc构建脚本\
43.5 将子项目添加到root buildSrc项目\
43.6 从构建中运行另一个构建\
43.7 为构建脚本声明外部依赖关系\
43.8 具有外部依赖性的构建脚本\
43.9 Ant可选的依赖关系\
44.1 使用只读和可配置的属性\
44.2 使用文件和目录属性\
44.3 隐式任务依赖关系\
44.4 列出属性\
45.1 在项目评估之前使用init脚本执行额外的配置\
45.2 声明init脚本的外部依赖关系\
45.3 具有外部依赖性的初始化脚本\
45.4 在init脚本中使用插件\
46.1 声明TestKit依赖关系\
46.2 声明JUnit的依赖\
46.3 在JUnit中使用GradleRunner\
46.4 使用GradleRunner和Spock\
46.5 使测试中的代码可用于测试\
46.6 将测试类中的代码注入测试版本\
46.7 将测试类中的代码注入到2.8之前的Gradle版本的测试版本中\
46.8 使用Java Gradle Development插件生成插件元数据\
46.9 自动将测试类下的代码注入测试版本\
46.10 重新配置Java Gradle Development插件的类路径生成约定\
46.11 为测试执行指定一个Gradle版本\
46.12 测试可缓存的任务\
47.1 使用Java插件\
47.2 构建一个Java项目\
47.3 添加Maven仓库\
47.4 添加依赖关系\
47.5 MANIFEST.MF的自定义\
47.6 添加一个测试系统属性\
47.7 发布JAR文件\
47.8 Eclipse插件\
47.9 Java示例 - 完整的构建文件\
47.10 多项目构建 - 分层布局\
47.11 多项目构建 - settings.gradle文件\
47.12 多项目构建 - 通用配置\
47.13 多项目构建 - 项目之间的依赖关系\
47.14 多项目构建 - 分发文件\
48.1 使用Java插件\
48.2 自定义Java源代码布局\
48.3 访问源集\
48.4 配置源集的源目录\
48.5 定义一个源集\
48.6 定义源集依赖关系\
48.7 编译源集\
48.8 为源集组装一个JAR\
48.9 为源集合生成Javadoc\
48.10 在源集中运行测试\
48.11 声明注释处理器\
48.12 在构建脚本中筛选测试\
48.13 JUnit类别\
48.14 分组TestNG测试\
48.15 保持TestNG测试的顺序\
48.16 按实例分组TestNG测试\
48.17 为子项目创建单元测试报告\
48.18 MANIFEST.MF的自定义\
48.19 创建一个清单对象.\
48.20 将MANIFEST.MF分别存档\
48.21 配置Java 6版本\
49.1 使用Java库插件\
49.2 声明API和实现依赖关系\
49.3 区分API和实现\
49.4 声明API和实现依赖关系\
49.5 配置Groovy插件以使用Java库\
50.1 战争插件\
50.2 使用Gretty插件运行Web应用程序\
51.1 使用战争插件\
51.2 战争插件的定制\
52.1 使用Ear插件\
52.2 耳塞的定制\
54.1 使用应用程序插件\
54.2 配置应用程序的主类\
54.3 配置默认的JVM设置\
54.4 在应用程序分发中包含来自其他任务的输出\
54.5 自动创建分发文件\
55.1 使用Java库分发插件\
55.2 配置分发名称\
55.3 在分发中包含文件\
56.1 Groovy插件\
56.2 依赖于Groovy\
56.3 Groovy示例 - 完整的构建文件\
57.1 使用Groovy插件\
57.2 自定义Groovy源代码布局\
57.3 Groovy依赖的配置\
57.4 配置Groovy测试依赖\
57.5 捆绑的Groovy依赖的配置\
57.6 Groovy文件依赖关系的配置\
57.7 为Groovy配置Java 6构建\
58.1 使用Scala插件\
58.2 自定义Scala源代码布局\
58.3 为生产代码声明一个Scala依赖项\
58.4 为测试代码声明一个Scala依赖项\
58.5 声明要使用的Zinc编译器的版本\
58.6 为所有配置强制使用scala-library依赖项\
58.7 强制使用锌配置的scala-library依赖项\
58.8 调整内存设置\
58.9 强制所有代码被编译\
58.10 为Scala配置Java 6 build\
58.11 明确指定目标IntelliJ IDEA版本\
59.1 使用ANTLR插件\
59.2 声明ANTLR版本\
59.3 为ANTLR设置自定义最大堆大小和额外参数\
60.1 使用Checkstyle插件\
60.2 使用config_loc属性\
60.3 自定义HTML报告\
61.1 使用CodeNarc插件\
62.1 使用FindBugs插件\
62.2 自定义HTML报告\
63.1 使用JDepend插件\
64.1 使用PMD插件\
65.1 应用JaCoCo插件\
65.2 配置JaCoCo插件设置\
65.3 配置测试任务\
65.4 配置违规规则\
65.5 配置测试任务\
65.6 使用应用程序插件来生成代码覆盖率数据\
65.7 由applicationCodeCoverageReport生成的覆盖率报告\
66.1 使用OSGi插件\
66.2 OSGi MANIFEST.MF文件的配置\
67.1 使用Eclipse插件\
67.2 使用Eclipse WTP插件\
67.3 部分覆盖类路径\
67.4 部分覆盖项目\
67.5 导出依赖关系\
67.6 定制XML\
68.1 使用IDEA插件\
68.2 部分重写模块\
68.3 部分重写项目\
68.4 导出依赖关系\
68.5 定制XML\
69.1 应用规则源插件\
69.2 模型创建规则\
69.3 模型变异规则\
69.4 创造一个任务\
69.5 一个托管类型\
69.6 一个String属性\
69.7 一个File属性\
69.8 一个Long属性\
69.9 一个布尔属性\
69.10 一个int属性\
69.11 一个托管的财产\
69.12 一个枚举类型的属性\
69.13 一个托管集\
69.14 强烈建模源集\
69.15 将规则应用于范围内的每个元素的DSL示例\
69.16 DSL配置规则\
69.17 需要时运行配置\
69.18 不需要时配置不运行\
69.19 DSL创建规则\
69.20 DSL创建规则没有初始化\
69.21 配置之前进行初始化\
69.22 嵌套的DSL创建规则\
69.23 嵌套的DSL配置规则\
69.24 地图中每个元素的DSL配置规则\
69.25 嵌套的DSL属性配置\
69.26 显示类型转换的DSL示例\
69.27 使用输入的DSL规则\
69.28 模型任务输出\
72.1 使用Java软件插件\
72.2 创建一个Java库\
72.3 配置源集\
72.4 创建一个新的源集\
72.5 组件报告\
72.6 声明依赖到一个库\
72.7 用一个明确的库声明一个依赖到一个项目\
72.8 用隐式库声明一个依赖到一个项目\
72.9 声明一个依赖到一个发布到Maven仓库的库\
72.10 使用简写符号声明模块依赖关系\
72.11 配置存储库以进行依赖关系解析\
72.12 指定api包\
72.13 指定api依赖关系\
72.14 主要来源\
72.15 客户端组件\
72.16 破坏的客户端组件\
72.17 重新编译客户端\
72.18 宣布目标平台\
72.19 声明二进制特定的来源\
72.20 宣布目标平台\
72.21 使用JUnit插件\
72.22 执行测试套件\
72.23 执行测试套件\
72.24 声明一个被测组件\
72.25 声明本地Java安装\
73.1 使用Play插件\
73.2 组件报告\
73.3 选择Play框架的一个版本\
73.4 将依赖关系添加到Play应用程序\
73.5 Play 2.6项目\
73.6 在Play 2.6项目中添加Guice依赖项\
73.7 将额外的源集添加到Play应用程序\
73.8 配置Scala编译器选项\
73.9 配置路由样式\
73.10 配置自定义资产管道\
73.11 配置Play子项目的依赖关系\
73.12 将额外的文件添加到Play应用程序分发\
73.13 同时应用Play和IDEA插件\
74.1 定义一个库组件\
74.2 定义可执行组件\
74.3 示例构建\
74.4 相关组件报告\
74.5 相关组件报告\
74.6 依赖于操作员组件的组件报告\
74.7 依赖于操作员组件的组件报告，包括测试套件\
74.8 组装依赖于运算符组件的传递/静态二进制文件的组件\
74.9 构建依赖于运算符组件的传递/静态二进制文件的组件\
74.10 添加一个自定义检查任务\
74.11 运行检查给定的二进制文件\
74.12 组件报告\
74.13 'cpp'插件\
74.14 C ++源码集\
74.15 'c'插件\
74.16 C源集\
74.17 “汇编器”插件\
74.18 'objective-c'插件\
74.19 'objective-cpp'插件\
74.20 适用于所有二进制文件的设置\
74.21 适用于所有共享库的设置\
74.22 适用于为“主要”可执行组件生成的所有二进制文件的设置\
74.23 仅适用于为“主”库组件生成的共享库的设置\
74.24 “Windows资源”插件\
74.25 配置Windows资源的位置\
74.26 建立一个资源专用的DLL\
74.27 为源集提供一个库依赖关系\
74.28 为二进制提供一个库依赖\
74.29 声明项目依赖关系\
74.30 创建一个预编译的头文件\
74.31 在源文件中包含预编译的头文件\
74.32 配置预编译头\
74.33 定义构建类型\
74.34 配置调试二进制文件\
74.35 定义平台\
74.36 定义味道\
74.37 在特定平台上定位组件\
74.38 建立所有可能的变体\
74.39 定义工具链\
74.40 重新配置工具参数\
74.41 定义目标平台\
74.42 注册CUnit测试\
74.43 运行CUnit测试\
74.44 注册GoogleTest测试\
75.1 一个使用自定义软件模型的例子\
75.2 声明一个自定义组件\
75.3 注册一个自定义组件\
75.4 声明一个自定义二进制文件\
75.5 注册自定义二进制文件\
75.6 声明一个自定义源集\
75.7 注册一个自定义源集\
75.8 生成文档二进制文件\
75.9 为文本源集合生成任务\
75.10 注册一个自定义源集\
75.11 一个使用自定义软件模型的例子\
75.12 组件报告\
75.13 公共类型和内部视图声明\
75.14 类型注册\
75.15 公众和内部数据突变\
75.16 示例构建脚本和模型报告输出\
B.1 变量范围：本地和脚本广泛\
B.2 独特的配置和执行阶段